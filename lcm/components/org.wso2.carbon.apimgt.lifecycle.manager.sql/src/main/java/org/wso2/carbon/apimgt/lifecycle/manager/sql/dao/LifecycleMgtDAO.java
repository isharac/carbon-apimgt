/*
 * Copyright (c) 2016, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * WSO2 Inc. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.wso2.carbon.apimgt.lifecycle.manager.sql.dao;

import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.wso2.carbon.apimgt.lifecycle.manager.sql.beans.LifecycleConfigBean;
import org.wso2.carbon.apimgt.lifecycle.manager.sql.beans.LifecycleHistoryBean;
import org.wso2.carbon.apimgt.lifecycle.manager.sql.beans.LifecycleStateBean;
import org.wso2.carbon.apimgt.lifecycle.manager.sql.config.LifecycleConfigBuilder;
import org.wso2.carbon.apimgt.lifecycle.manager.sql.constants.Constants;
import org.wso2.carbon.apimgt.lifecycle.manager.sql.constants.SQLConstants;
import org.wso2.carbon.apimgt.lifecycle.manager.sql.exception.LifecycleManagerDatabaseException;
import org.wso2.carbon.apimgt.lifecycle.manager.sql.utils.LifecycleMgtDBUtil;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;


/**
 * This class represent the DAO layer for lifecycle related operations.
 */
public class LifecycleMgtDAO {

    private static final Logger log = LoggerFactory.getLogger(LifecycleMgtDAO.class);

    private LifecycleMgtDAO() {

    }

    /**
     * Method to get the instance of the LCMgtDAO.
     *
     * @return {@link LifecycleMgtDAO} instance
     */
    public static LifecycleMgtDAO getInstance() {
        return LCMgtDAOHolder.INSTANCE;
    }

    /**
     * Add lifecycle config for a specific tenant.
     *
     * @param lifecycleConfigBean                  Contains information about name and content.
     * @throws LifecycleManagerDatabaseException   If failed to add lifecycle.
     */
    public void addLifecycle(LifecycleConfigBean lifecycleConfigBean)
            throws LifecycleManagerDatabaseException {
        Connection connection = null;
        PreparedStatement prepStmt = null;

        String query = SQLConstants.ADD_LIFECYCLE_SQL;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            connection.setAutoCommit(false);
            String dbProductName = connection.getMetaData().getDatabaseProductName();
            boolean returnsGeneratedKeys = LifecycleMgtDBUtil.canReturnGeneratedKeys(dbProductName);
            if (returnsGeneratedKeys) {
                prepStmt = connection.prepareStatement(query, new String[] {
                        LifecycleMgtDBUtil.getConvertedAutoGeneratedColumnName(dbProductName, Constants.LC_ID) });
            } else {
                prepStmt = connection.prepareStatement(query);
            }
            prepStmt.setString(1, lifecycleConfigBean.getLcName());
            prepStmt.setBinaryStream(2, new ByteArrayInputStream(lifecycleConfigBean.getLcContent().getBytes(
                    StandardCharsets.UTF_8)));
            prepStmt.execute();
            connection.commit();
        } catch (SQLException e) {
            try {
                if (connection != null) {
                    connection.rollback();
                }
            } catch (SQLException e1) {
                log.error("Error while roll back operation for adding new lifecycle with name :" + lifecycleConfigBean
                        .getLcName(), e);
            }
            handleException("Error while adding the lifecycle " + lifecycleConfigBean.getLcName(), e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, null);
        }
    }

    /**
     * Update existing lifecycle config..
     *
     * @param lifecycleConfigBean                  Contains information about name and content.
     * @throws LifecycleManagerDatabaseException   If failed to add lifecycle.
     */
    public void updateLifecycle(LifecycleConfigBean lifecycleConfigBean)
            throws LifecycleManagerDatabaseException {
        Connection connection = null;
        PreparedStatement prepStmt = null;

        String query = SQLConstants.UPDATE_LIFECYCLE_SQL;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            connection.setAutoCommit(false);
            prepStmt = connection.prepareStatement(query);
            prepStmt.setBinaryStream(1, new ByteArrayInputStream(lifecycleConfigBean.getLcContent().getBytes
                    (StandardCharsets.UTF_8)));
            prepStmt.setString(2, lifecycleConfigBean.getLcName());
            prepStmt.executeUpdate();
            connection.commit();
        } catch (SQLException e) {
            try {
                if (connection != null) {
                    connection.rollback();
                }
            } catch (SQLException e1) {
                log.error("Error while roll back operation for updating existing lifecycle with name :"
                        + lifecycleConfigBean.getLcName(), e);
            }
            handleException("Error while updating the lifecycle" + lifecycleConfigBean.getLcName(), e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, null);
        }
    }

    /**
     * Delete existing lifecycle config. Will be called only lifecycle is not associated with any asset.
     *
     * @param lcName                                Contains information about name and content.
     * @throws LifecycleManagerDatabaseException    If failed to add lifecycle.
     */
    public void deleteLifecycle(String lcName) throws LifecycleManagerDatabaseException {
        Connection connection = null;
        PreparedStatement prepStmt = null;

        String query = SQLConstants.DELETE_LIFECYCLE_SQL;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            connection.setAutoCommit(false);
            prepStmt = connection.prepareStatement(query);
            prepStmt.setString(1, lcName);
            prepStmt.execute();
            connection.commit();
        } catch (SQLException e) {
            try {
                if (connection != null) {
                    connection.rollback();
                }
            } catch (SQLException e1) {
                log.error("Error while roll back operation for deleting lifecycle with name :" + lcName, e);
            }
            handleException("Error while deleting the lifecycle " + lcName, e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, null);
        }
    }

    /**
     * Get lifecycle list of specific tenant.
     *
     * @return                                      Lifecycle list containing names;
     * @throws LifecycleManagerDatabaseException    If failed to get lifecycle list.
     */
    public String[] getLifecycleList() throws LifecycleManagerDatabaseException {
        List<String> lifecycleList = new ArrayList<>();
        Connection connection = null;
        PreparedStatement prepStmt = null;
        ResultSet rs = null;
        String query = SQLConstants.GET_LIFECYCLE_LIST_SQL;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            prepStmt = connection.prepareStatement(query);
            rs = prepStmt.executeQuery();
            while (rs.next()) {
                lifecycleList.add(rs.getString(Constants.LIFECYCLE_LIST));
            }

        } catch (SQLException e) {
            handleException("Error while getting the lifecycle list. ", e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, rs);
        }
        return lifecycleList.toArray(new String[0]);
    }

    /**
     * Get lifecycle configuration.
     *
     * @param lcName                                Name of the lifecycle
     * @return                                      Bean with content and name
     * @throws LifecycleManagerDatabaseException    If failed to get lifecycle config.
     */
    public LifecycleConfigBean getLifecycleConfig(String lcName)
            throws LifecycleManagerDatabaseException {
        LifecycleConfigBean lifecycleConfigBean = new LifecycleConfigBean();
        Connection connection = null;
        PreparedStatement prepStmt = null;
        ResultSet rs = null;
        String query = SQLConstants.GET_LIFECYCLE_CONFIG_SQL;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            prepStmt = connection.prepareStatement(query);
            prepStmt.setString(1, lcName);
            rs = prepStmt.executeQuery();
            if (rs.next()) {
                lifecycleConfigBean.setLcName(rs.getString(Constants.LIFECYCLE_NAME));
                InputStream rawInputStream = rs.getBinaryStream(Constants.LIFECYCLE_CONTENT);
                lifecycleConfigBean.setLcContent(IOUtils.toString(rawInputStream));
            } else {
                throw new LifecycleManagerDatabaseException("No lifecycle config exist with name " + lcName);
            }

        } catch (SQLException e) {
            handleException("Error while getting the lifecycle content for lifecycle " + lcName, e);
        } catch (IOException e) {
            handleException("Error while converting lifecycle content stream to string", e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, rs);
        }
        return lifecycleConfigBean;
    }

    /**
     * Set initial lifecycle state.
     *
     * @param initialState                          Initial state provided in lifecycle config.
     * @param lcName                                Name of the lifecycle
     * @param user                                  The user who invoked the action. This will be used for
     *                                              auditing purposes.
     * @return                                      UUID generated by framework which is stored as reference by
     *                                              external systems.
     * @throws LifecycleManagerDatabaseException    If failed to add initial lifecycle state.
     */
    public String addLifecycleState(String initialState, String lcName, String user)
            throws LifecycleManagerDatabaseException {
        Connection connection = null;
        PreparedStatement prepStmt1 = null;
        PreparedStatement prepStmt2 = null;
        ResultSet rs1 = null;
        String uuid = null;
        int lcDefinitionId = -1;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            connection.setAutoCommit(false);
            prepStmt1 = connection.prepareStatement(SQLConstants.GET_LIFECYCLE_DEFINITION_ID_FROM_NAME_SQL);
            prepStmt1.setString(1, lcName);
            rs1 = prepStmt1.executeQuery();

            while (rs1.next()) {
                lcDefinitionId = rs1.getInt(Constants.LIFECYCLE_DEFINITION_ID);
            }
            if (lcDefinitionId == -1) {
                throw new LifecycleManagerDatabaseException("There is no lifecycle configuration with name " + lcName);
            }
            uuid = generateUUID();
            prepStmt2 = connection.prepareStatement(SQLConstants.ADD_LIFECYCLE_STATE_SQL);
            prepStmt2.setString(1, uuid);
            prepStmt2.setInt(2, lcDefinitionId);
            prepStmt2.setString(3, initialState);
            prepStmt2.execute();
            connection.commit();
            addLifecycleHistory(uuid, null, initialState, user);

        } catch (SQLException e) {
            uuid = null;
            try {
                if (connection != null) {
                    connection.rollback();
                }
            } catch (SQLException e1) {
                log.error("Error while roll back operation for setting initial lifecycle state :" + initialState, e);
            }
            handleException("Error while associating the lifecycle " + lcName, e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt1, null, rs1);
            LifecycleMgtDBUtil.closeAllConnections(prepStmt2, connection, null);
        }
        return uuid;
    }

    /**
     * Change lifecycle state.
     *
     * @param lifecycleStateBean                    Bean containing lifecycle id and required state.
     * @param user                                  The user who invoked the action. This will be used for
     *                                              auditing purposes.
     * @throws LifecycleManagerDatabaseException    If failed to change lifecycle state.
     */
    public void changeLifecycleState(LifecycleStateBean lifecycleStateBean, String user)
            throws LifecycleManagerDatabaseException {
        Connection connection = null;
        PreparedStatement prepStmt = null;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            connection.setAutoCommit(false);
            prepStmt = connection.prepareStatement(SQLConstants.UPDATE_LIFECYCLE_STATE_SQL);
            prepStmt.setString(1, lifecycleStateBean.getPostStatus());
            prepStmt.setString(2, lifecycleStateBean.getStateId());
            prepStmt.executeUpdate();
            connection.commit();
            addLifecycleHistory(lifecycleStateBean.getStateId(), lifecycleStateBean.getPreviousStatus(),
                    lifecycleStateBean.getPostStatus(), user);

        } catch (SQLException e) {
            try {
                if (connection != null) {
                    connection.rollback();
                }
            } catch (SQLException e1) {
                log.error("Error while roll back operation for lifecycle state change :" + lifecycleStateBean
                        .getPostStatus(), e);
            }
            handleException("Error while changing the lifecycle state to " + lifecycleStateBean.getPostStatus(), e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, null);
        }
    }

    /**
     * Get lifecycle state data for a particular uuid.
     *
     * @param uuid                                  Reference variable that maps lc data with external system.
     * @return                                      Life cycle state bean with all the required information
     * @throws LifecycleManagerDatabaseException    If failed to get lifecycle state data.
     */
    public LifecycleStateBean getLifecycleStateDataFromId(String uuid) throws LifecycleManagerDatabaseException {
        LifecycleStateBean lifecycleStateBean = new LifecycleStateBean();
        Connection connection = null;
        PreparedStatement prepStmt = null;
        PreparedStatement prepStmt2 = null;
        ResultSet rs = null;
        ResultSet rs2 = null;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            prepStmt = connection.prepareStatement(SQLConstants.GET_LIFECYCLE_NAME_FROM_ID_SQL);
            prepStmt.setString(1, uuid);
            rs = prepStmt.executeQuery();
            if (rs.next()) {
                lifecycleStateBean.setLcName(rs.getString(Constants.LIFECYCLE_NAME));
                String lcState = rs.getString(Constants.LIFECYCLE_STATUS);
                lifecycleStateBean.setPostStatus(lcState);
                lifecycleStateBean.setStateId(uuid);

                prepStmt2 = connection.prepareStatement(SQLConstants.GET_CHECKLIST_DATA);
                prepStmt2.setString(1, uuid);
                prepStmt2.setString(2, lcState);
                rs2 = prepStmt2.executeQuery();
                Map<String, Boolean> checkListData = new HashMap<>();
                while (rs2.next()) {
                    checkListData
                            .put(rs2.getString(Constants.CHECKLIST_NAME), rs2.getBoolean(Constants.CHECKLIST_VALUE));
                }
                lifecycleStateBean.setCheckListData(checkListData);
            } else {
                throw new LifecycleManagerDatabaseException("No state data associated with lifecycle id :" + uuid);
            }

        } catch (SQLException e) {
            handleException("Error while getting the lifecycle state data for id" + uuid, e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt2, null, rs2);
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, rs);
        }
        return lifecycleStateBean;
    }

    /**
     * Get all lifecycle configurations from lc database.
     *
     * @return                                      List of beans with content and name
     * @throws LifecycleManagerDatabaseException    If failed to get lifecycle config.
     */
    public LifecycleConfigBean[] getAllLifecycleConfigs() throws LifecycleManagerDatabaseException {
        List<LifecycleConfigBean> lifecycleConfigBeanList = new ArrayList<>();
        Connection connection = null;
        PreparedStatement prepStmt = null;
        ResultSet rs = null;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            prepStmt = connection.prepareStatement(SQLConstants.GET_ALL_LIFECYCLE_CONFIGS_SQL);
            rs = prepStmt.executeQuery();
            while (rs.next()) {
                LifecycleConfigBean lifecycleConfigBean = new LifecycleConfigBean();
                lifecycleConfigBean.setLcName(rs.getString(Constants.LIFECYCLE_NAME));
                InputStream rawInputStream = rs.getBinaryStream(Constants.LIFECYCLE_CONTENT);
                lifecycleConfigBean.setLcContent(IOUtils.toString(rawInputStream));
                lifecycleConfigBeanList.add(lifecycleConfigBean);
            }

        } catch (SQLException e) {
            handleException("Error while getting the lifecycle list", e);
        } catch (IOException e) {
            handleException("Error while converting lifecycle content stream to string", e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, rs);
        }
        return lifecycleConfigBeanList.toArray(new LifecycleConfigBean[0]);
    }

    /**
     * Check lifecycle already exist with same name.
     *
     * @param lcName                                Name of the lifecycle
     * @return                                      Bean with content and name
     * @throws LifecycleManagerDatabaseException
     */
    public boolean checkLifecycleExist(String lcName) throws LifecycleManagerDatabaseException {
        Connection connection = null;
        PreparedStatement prepStmt = null;
        ResultSet rs = null;
        boolean result = false;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            prepStmt = connection.prepareStatement(SQLConstants.CHECK_LIFECYCLE_EXIST_SQL);
            prepStmt.setString(1, lcName);
            rs = prepStmt.executeQuery();
            result = rs.next();
        } catch (SQLException e) {
            handleException("Error while checking for lifecycle exist with name" + lcName, e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, rs);
        }
        return result;
    }

    /**
     * Method used to update lifecycle history tables. Invoked when association and updating lifecycle.
     *
     * @param id                            UUID of the lifecycle state. (Associates with asset)
     * @param previousState                 Current state.
     * @param postState                     Target state.
     * @param user                          The user associated with lifecycle operation.
     * @throws LifecycleManagerDatabaseException
     */
    private void addLifecycleHistory(String id, String previousState, String postState, String user) {
        if (!LifecycleConfigBuilder.getLifecycleConfig().isEnableHistory()) {
            return;
        }
        Connection connection = null;
        PreparedStatement prepStmt = null;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            connection.setAutoCommit(false);
            String dbProductName = connection.getMetaData().getDatabaseProductName();
            boolean returnsGeneratedKeys = LifecycleMgtDBUtil.canReturnGeneratedKeys(dbProductName);
            if (returnsGeneratedKeys) {
                prepStmt = connection.prepareStatement(SQLConstants.INSERT_LIFECYCLE_HISTORY_SQL, new String[] {
                        LifecycleMgtDBUtil.getConvertedAutoGeneratedColumnName(dbProductName, Constants.LC_ID) });
            } else {
                prepStmt = connection.prepareStatement(SQLConstants.INSERT_LIFECYCLE_HISTORY_SQL);
            }
            //prepStmt = connection.prepareStatement(query);
            prepStmt.setString(1, id);
            prepStmt.setString(2, previousState);
            prepStmt.setString(3, postState);
            prepStmt.setString(4, user);
            prepStmt.setTimestamp(5, new Timestamp(System.currentTimeMillis()));
            prepStmt.execute();
            connection.commit();
        } catch (SQLException e) {
            try {
                if (connection != null) {
                    connection.rollback();
                }
            } catch (SQLException e1) {
                log.error("Error while roll back operation for lifecycle history data insertion ", e);
            }
            log.error("Error while adding the lifecycle history ", e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, null);
        }
    }

    /**
     * Method used to get lifecycle history related to particular uuid.
     *
     * @param uuid                                  UUID of the lifecycle state. (Associates with asset)
     * @return                                      List of state transitions for given uuid.
     *
     * @throws LifecycleManagerDatabaseException
     */
    public List<LifecycleHistoryBean> getLifecycleHistoryFromId(String uuid) throws LifecycleManagerDatabaseException {
        Connection connection = null;
        PreparedStatement prepStmt = null;
        ResultSet rs = null;
        List<LifecycleHistoryBean> lifecycleHistoryBeanList = new ArrayList<>();
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            prepStmt = connection.prepareStatement(SQLConstants.GET_LIFECYCLE_HISTORY_OF_UUID);
            prepStmt.setString(1, uuid);
            rs = prepStmt.executeQuery();
            while (rs.next()) {
                LifecycleHistoryBean lifecycleHistoryBean = new LifecycleHistoryBean();
                lifecycleHistoryBean.setPreviousState(rs.getString(Constants.PREV_STATE));
                lifecycleHistoryBean.setPostState(rs.getString(Constants.POST_STATE));
                lifecycleHistoryBean.setUser(rs.getString(Constants.USER));
                lifecycleHistoryBean.setUpdatedTime(rs.getTimestamp(Constants.TIME));
                lifecycleHistoryBeanList.add(lifecycleHistoryBean);
            }
        } catch (SQLException e) {
            handleException("Error while getting lifecycle history for id : " + uuid, e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, rs);
        }
        return lifecycleHistoryBeanList;
    }

    /**
     * Method used to check if the lifecycle is attached to a particular asset.
     *
     * @param lcName                                UUID of the lifecycle state. (Associates with asset)
     * @return                                      True if lifecycle is associated with assets.
     * @throws LifecycleManagerDatabaseException
     */
    public boolean isLifecycleIsInUse(String lcName) throws LifecycleManagerDatabaseException {
        Connection connection = null;
        PreparedStatement prepStmt = null;
        ResultSet rs = null;
        boolean result = false;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            prepStmt = connection.prepareStatement(SQLConstants.CHECK_LIFECYCLE_IN_USE);
            prepStmt.setString(1, lcName);
            rs = prepStmt.executeQuery();
            result = rs.next();
        } catch (SQLException e) {
            handleException("Error while checking for lifecycle associated with assets" + lcName, e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, rs);
        }
        return result;
    }

    /**
     * Method used to remove lifecycle state data for a given id.
     *
     * @param uuid                                  UUID of the lifecycle state. (Associates with asset)
     * @throws LifecycleManagerDatabaseException
     */
    public void removeLifecycleState (String uuid) throws LifecycleManagerDatabaseException {
        Connection connection = null;
        PreparedStatement prepStmt = null;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            connection.setAutoCommit(false);
            prepStmt = connection.prepareStatement(SQLConstants.REMOVE_LIFECYCLE_STATE);
            prepStmt.setString(1, uuid);
            prepStmt.execute();
            connection.commit();
        } catch (SQLException e) {
            try {
                if (connection != null) {
                    connection.rollback();
                }
            } catch (SQLException e1) {
                log.error("Error while roll back operation for lifecycle delete operation ", e);
            }
            handleException("Error while deleting the lifecycle id  " + uuid, e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, null);
        }
    }

    /**
     * Method used to update data related to check list item operation.
     *
     * @param uuid                                  UUID of the lifecycle state. (Associates with asset)
     * @param lcState                               State in which the checklist is associated with.
     * @param checkListName                         Name of the check list in which operation was performed
     * @param value                                 Value of the check list item. (Selected or not selected)
     *
     * @throws LifecycleManagerDatabaseException
     */
    public void changeCheckListItemData(String uuid, String lcState, String checkListName, boolean value)
            throws LifecycleManagerDatabaseException {
        Connection connection = null;
        PreparedStatement prepStmt1 = null;
        PreparedStatement prepStmt2 = null;
        PreparedStatement prepStmt3 = null;
        ResultSet rs = null;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            prepStmt1 = connection.prepareStatement(SQLConstants.CHECK_LIST_ITEM_EXIST);
            prepStmt1.setString(1, uuid);
            prepStmt1.setString(2, lcState);
            prepStmt1.setString(3, checkListName);
            rs = prepStmt1.executeQuery();
            connection.setAutoCommit(false);
            if (rs.next()) {
                prepStmt2 = connection.prepareStatement(SQLConstants.UPDATE_CHECK_LIST_ITEM_DATA);
                prepStmt2.setBoolean(1, value);
                prepStmt2.setString(2, uuid);
                prepStmt2.setString(3, lcState);
                prepStmt2.setString(4, checkListName);
                prepStmt2.executeUpdate();
            } else {
                prepStmt3 = connection.prepareStatement(SQLConstants.ADD_CHECK_LIST_ITEM_DATA);
                prepStmt3.setString(1, uuid);
                prepStmt3.setString(2, lcState);
                prepStmt3.setString(3, checkListName);
                prepStmt3.setBoolean(4, value);
                prepStmt3.execute();
            }
            connection.commit();
        } catch (SQLException e) {
            try {
                if (connection != null) {
                    connection.rollback();
                }
            } catch (SQLException e1) {
                log.error("Error while roll back operation for adding check list item data ", e);
            }
            handleException("Error while adding  checklist data for id " + uuid, e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt1, null, rs);
            LifecycleMgtDBUtil.closeAllConnections(prepStmt2, null, null);
            LifecycleMgtDBUtil.closeAllConnections(prepStmt3, connection, null);
        }

    }

    /**
     * Method used to clear check list item data related to previous state when performing lifecycle state change
     * operation.
     *
     * @param uuid                                  UUID of the lifecycle state.
     * @param lcState                               State in which the checklist is associated with.
     *
     * @throws LifecycleManagerDatabaseException
     */
    public void clearCheckListItemData(String uuid, String lcState) throws LifecycleManagerDatabaseException {
        Connection connection = null;
        PreparedStatement prepStmt = null;
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            connection.setAutoCommit(false);
            prepStmt = connection.prepareStatement(SQLConstants.CLEAR_CHECK_LIST_DATA);
            prepStmt.setBoolean(1, false);
            prepStmt.setString(2, uuid);
            prepStmt.setString(3, lcState);
            prepStmt.executeUpdate();
            connection.commit();
        } catch (SQLException e) {
            try {
                if (connection != null) {
                    connection.rollback();
                }
            } catch (SQLException e1) {
                log.error("Error while roll back operation for clearing checklist item data ", e);
            }
            handleException("Error while clearing  checklist data for id " + uuid + "and state " + lcState, e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, null);
        }
    }

    /**
     * This method provides set of lifecycle ids in a particular state.
     * @param state`
     * @return  List of lifecycle ids in the given state.
     * @throws LifecycleManagerDatabaseException
     */
    public List<String> getLifecycleIdsFromState(String state) throws LifecycleManagerDatabaseException {
        Connection connection = null;
        PreparedStatement prepStmt = null;
        ResultSet rs = null;
        List<String> lifecycleIdList = new ArrayList<>();
        try {
            connection = LifecycleMgtDBUtil.getConnection();
            prepStmt = connection.prepareStatement(SQLConstants.GET_LIFECYCLE_IDS_IN_STATE);
            prepStmt.setString(1, state);
            rs = prepStmt.executeQuery();
            while (rs.next()) {
                lifecycleIdList.add(rs.getString(Constants.ID));
            }
        } catch (SQLException e) {
            handleException("Error while getting list of lifecycle ids in state" + state, e);
        } finally {
            LifecycleMgtDBUtil.closeAllConnections(prepStmt, connection, rs);
        }
        return lifecycleIdList;
    }

    private void handleException(String msg, Throwable t) throws LifecycleManagerDatabaseException {
        log.error(msg, t);
        throw new LifecycleManagerDatabaseException(msg, t);
    }

    private String generateUUID() {
        return UUID.randomUUID().toString().replaceAll("-", "");
    }

    /**
     * This is an inner class to hold the instance of the LCMgtDAO.
     * The reason for writing it like this is to guarantee that only one instance would be created.
     */
    private static class LCMgtDAOHolder {

        private static final LifecycleMgtDAO INSTANCE = new LifecycleMgtDAO();
    }
}
